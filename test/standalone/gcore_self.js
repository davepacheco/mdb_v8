/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2018, Joyent, Inc.
 */

/*
 * test/standalone/gcore_self.js: utility function for creating a core file of
 * the current process.
 */

var assert = require('assert');
var childprocess = require('child_process');
var fs = require('fs');
var vasync = require('vasync');
var VError = require('verror');

/* Public interface */
module.exports = gcoreSelf;

var DSCRIPT_FILE_SENTINEL = '/mdb_v8/sentinel';
var DSCRIPT_SENTINEL_BEGIN = 'mdb_v8: dtrace has started tracing';
var DSCRIPT_SENTINEL_DONE = 'mdb_v8: gcore has finished';
var DSCRIPT_SUFFIX = [
    '/* This script was auto-generated by the mdb_v8 test suite. */',
    '',
    '#pragma D option destructive',
    '#pragma D option quiet',
    '',
    'BEGIN',
    '{',
    '    printf("%s\\n", ' + JSON.stringify(DSCRIPT_SENTINEL_BEGIN) + ');',
    '}',
    '',
    'syscall::stat:entry,',
    'syscall::stat64:entry',
    '/pid == TARGET_PID && copyinstr(arg0) == ' +
	JSON.stringify(DSCRIPT_FILE_SENTINEL) + '/',
    '{',
    '    stop();',
    '    system("gcore -o %s %d && echo %s; prun %d", COREBASE, TARGET_PID,',
    '        ' + JSON.stringify(DSCRIPT_SENTINEL_DONE) + ', TARGET_PID);',
    '    exit(0);',
    '}'
].join('\n');

function makeDTraceArgs(corebase)
{
	var script;

	script = [
	    '#define COREBASE   ' + JSON.stringify(corebase),
	    '#define TARGET_PID ' + process.pid,
	    DSCRIPT_SUFFIX
	].join('\n');

	return ({
	    'program': 'dtrace',
	    'script': script,
	    'argv': [ '-Cs', '/dev/stdin' ]
	});
}

/*
 * Utility function for saving a core file of the current process using
 * gcore(1M).  This is used in a number of tests as the basis for exercising
 * mdb_v8.  This function invokes "callback" upon completion with arguments:
 *
 * - err, if there was any error
 * - filename, with the path to the specified file
 *
 * This implementation is a lot more complex than one might expect because it
 * attempts to ensure that the core file is taken when GC is not running.
 */
function gcoreSelf(callback)
{
	var prefix, corefile, dtrace_args;
	var dtrace, state, error, buffered;

	prefix = '/var/tmp/node';
	corefile = prefix + '.' + process.pid;
	dtrace_args = makeDTraceArgs(prefix);
	state = 'wait_for_trace';
	error = null;

	console.error('gcoreSelf: begin');
	dtrace = childprocess.spawn(dtrace_args.program, dtrace_args.argv);
	dtrace.stdin.end(dtrace_args.script);
	dtrace.stderr.on('data', function (data) {
		process.stderr.write('gcoreSelf: dtrace stderr: ' + data);
	});

	buffered = '';
	dtrace.stdout.on('data', function (data) {
		var sentinelExists;

		process.stderr.write('gcoreSelf: dtrace stdout: ' + data);
		buffered += data;

		if (state == 'wait_for_trace') {
			if (buffered.indexOf(DSCRIPT_SENTINEL_BEGIN) == -1) {
				/* Wait for the sentinel. */
				console.error('gcoreSelf: waiting extra');
				return;
			}

			/*
			 * We have to stat the file synchronously in order to
			 * know for sure that this thread will not be running
			 * GC.  We don't really care about the result, but we
			 * check to be sure things haven't flown off the rails.
			 */
			console.error('gcoreSelf: dtrace is tracing');
			state = 'wait_for_result';
			try {
				fs.statSync(DSCRIPT_FILE_SENTINEL);
				sentinelExists = true;
			} catch (err) {
				assert.strictEqual(err.code, 'ENOENT');
				sentinelExists = false;
			}
			assert.ok(sentinelExists === false,
			    'statSync of sentinel unexpectedly succeeded!');

			/*
			 * It shouldn't be possible to see both the initial
			 * sentinel and the final sentinel on the same tick
			 * because we must take action in between these.
			 */
			assert.strictEqual(-1,
			    buffered.indexOf(DSCRIPT_SENTINEL_DONE));
			return;
		}

		if (state == 'wait_for_result') {
			if (buffered.indexOf(DSCRIPT_SENTINEL_DONE) == -1) {
				/* Wait for the second sentinel. */
				console.error('gcoreSelf: waiting extra');
				return;
			}

			/* Success! */
			state = 'succeeded';
			console.error('gcoreSelf: gcore completed');
		}
	});

	dtrace.on('exit', function (code) {
		if (code !== 0) {
			error = new VError('dtrace exited unexpectedly with ' +
			    'code %s', code.toString());
		} else if (state != 'succeeded') {
			error = new VError('dtrace exited successfully, but ' +
			    'never received sentinel');
		}

		if (error) {
			callback(error);
		} else {
			console.error('gcoreSelf: gcore created %s', corefile);
			callback(null, corefile);
		}
	});
}
