#!/usr/bin/env node

/*
 * mdbv8diff FILE1 FILE2: given FILE1 and FILE2 as test output from mdb_v8,
 * report differences.  This is intended for regression testing across versions.
 * These inputs should be generated as:
 *
 *    ::findjsobjects -l | ::findjsobjects ! sort > tmp
 *    ::cat tmp | ::jsprint -ad2 -N 0t100 > file
 *
 * In this example, "file" is the file that would become one of the inputs to
 * this program.  The other input would come from applying the same process
 * using a different version of mdb_v8.
 */

var mod_assertplus = require('assert-plus');
var mod_cmdutil = require('cmdutil');
var mod_events = require('events');
var mod_fs = require('fs');
var mod_lstream = require('lstream');
var mod_stream = require('stream');
var mod_util = require('util');
var mod_vstream = require('vstream');

var sprintf = require('extsprintf').sprintf;
var VError = require('verror');

var JoinStream = require('./vstream-join');

function main()
{
	var source1, source2;
	var join, diff, serializer;

	mod_cmdutil.configure({
	    'usageMessage': 'Compare output from mdb_v8.',
	    'synopses': [ 'FILE1 FILE2' ]
	});

	if (process.argv.length != 4) {
		mod_cmdutil.usage();
	}

	source1 = createInputStream(process.argv[2]);
	source2 = createInputStream(process.argv[3]);
	join = new JoinStream({
	    'joinOnIndex': 0,
	    'sources': [ source1, source2 ]
	});

	diff = new DiffStream({
	    'labels': [ process.argv[2], process.argv[3] ]
	});
	join.pipe(diff);

	serializer = new DiffStreamSerializer();
	diff.pipe(serializer);
	serializer.pipe(process.stdout);

	process.stdout.on('error', function (err) {
		if (err['code'] == 'EPIPE')
			return;
		throw (err);
	});

	diff.on('warn', function (context, kind, error) {
		mod_cmdutil.warn(error.message);
		console.error('    at ', context.label());
	});

	diff.on('end', function () {
		diff.vsDumpCounters(process.stderr);
	});
}

/*
 * Returns the tail of a stream pipeline that goes:
 *
 *     File read stream (path) -> line parser -> mdbv8 parser
 */
function createInputStream(path)
{
	var filestream, lstream, parser;

	filestream = mod_fs.createReadStream(path);
	filestream.on('error', function (err) {
		mod_cmdutil.fail(new VError(err, 'open "%s"', path));
	});

	lstream = new mod_lstream();
	mod_vstream.wrapTransform(lstream);
	filestream.pipe(lstream);

	parser = new ParserStream();
	lstream.pipe(parser);

	return (parser);
}

function ParserStream()
{
	this.ps_accum = [];
	mod_stream.Transform.call(this, { 'objectMode': true });
	mod_vstream.wrapTransform(this);
}

mod_util.inherits(ParserStream, mod_stream.Transform);

ParserStream.prototype._transform = function (chunk, _, callback)
{
	/* There should be an lstream in front of this stream. */
	mod_assertplus.equal(chunk.indexOf('\n'), -1);

	this.ps_accum.push(chunk.trim());

	/*
	 * This gnarly regexp matches top-level values that are empty objects
	 * or empty arrays (e.g., "{}" and "[]").
	 */
	if (chunk.charAt(0) == '}' || chunk.charAt(0) == ']' ||
	    /* JSSTYLED */
	    /^[0-9a-fA-F]+: [{[][}\]]/.test(chunk)) {
		this.valueDone();
	}

	setImmediate(callback);
};

ParserStream.prototype._flush = function (callback)
{
	if (this.ps_accum.length > 0)
		this.valueDone();
	setImmediate(callback);
};

ParserStream.prototype.valueDone = function ()
{
	var lines, line, err, colon, addr;
	var parsed, opener;

	mod_assertplus.ok(this.ps_accum.length > 0);
	lines = this.ps_accum;
	this.ps_accum = [];

	line = lines[lines.length - 1];
	if (line != ']' && line != '}') {
		err = new VError('unrecognized value');
		this.vsWarn(err, 'unrecognized value');
		return;
	}

	line = lines[0];
	colon = line.indexOf(':');
	if (colon == -1) {
		err = new VError('value has no address');
		this.vsWarn(err, 'value has no address');
		return;
	}

	/*
	 * "Parse" is a strong word for what we're doing.  If we wanted to do
	 * this reliably, we should get mdb_v8 emitting parseable output.  We're
	 * getting there, but the point of this tool is to help identify changes
	 * in the existing, not-very-parseable output.  It's just supposed to be
	 * a little less unwieldy than diff(1).  So we basically just break
	 * things out on a by-object basis, compare lines one-by-one, and ignore
	 * known changes.
	 */
	addr = line.substr(0, colon);
	parsed = {};
	parsed['addr'] = addr;
	opener = line.charAt(colon + ': '.length);
	if (opener == '{') {
		parsed['type'] = 'object';
		parsed['lines'] = lines.slice(1);
		this.push([ addr, parsed ]);
	} else if (opener == '[') {
		parsed['type'] = 'array';
		parsed['lines'] = lines.slice(1);
		this.push([ addr, parsed ]);
	} else {
		err = new VError('unknown type');
		this.vsWarn(err, 'unknown type');
	}
};


function DiffStream(args)
{
	mod_assertplus.object(args, 'args');
	mod_assertplus.arrayOfString(args.labels, 'args.labels');
	mod_assertplus.equal(args.labels.length, 2);

	mod_stream.Transform.call(this, { 'objectMode': true });
	mod_vstream.wrapTransform(this);

	this.ds_labels = args.labels.slice(0);
}

mod_util.inherits(DiffStream, mod_stream.Transform);

DiffStream.prototype._transform = function (joined, _, callback)
{
	var rowlabel, label1, label2;
	var value1, value2;
	var i, max;

	if (joined.length != 3) {
		this.vsWarn(new Error('garbled value'), 'garbled value');
		setImmediate(callback);
		return;
	}

	mod_assertplus.string(joined[0], 'joined[0]');
	rowlabel = joined[0];

	if (this.ignoreAddress(rowlabel)) {
		setImmediate(callback);
		return;
	}

	label1 = this.ds_labels[0];
	value1 = joined[1];

	label2 = this.ds_labels[1];
	value2 = joined[2];

	if (value1 === null) {
		this.push({
		    'label': rowlabel,
		    'message': sprintf('only in %s', label2)
		});
		return;
	}
	if (value2 === null) {
		this.push({
		    'label': rowlabel,
		    'message': sprintf('only in %s', label1)
		});
		return;
	}

	value1 = value1[1];
	value2 = value2[1];
	if (value1['type'] != value2['type']) {
		this.push({
		    'label': rowlabel,
		    'messages': [ {
		        'source': label1,
			'message': sprintf('type %s', value1['type'])
		    }, {
		        'source': label2,
			'message': sprintf('type %s', value2['type'])
		    } ]
		});

		return;
	}

	/*
	 * Compare lines one-by-one.  Really, the only difference
	 * between this tool and diff(1) is that we're going to ignore
	 * certain known differences.
	 */
	max = Math.max(value1['lines'].length, value2['lines'].length);
	for (i = 0; i < max; i++) {
		if (i >= value1['lines'].length) {
			this.push({
			    'label': rowlabel,
			    'message': sprintf('line %d: property missing ' +
			        'from "%s"', i + 1, label1)
			});
		} else if (i >= value2['lines'].length) {
			this.push({
			    'label': rowlabel,
			    'message': sprintf('line %d: property missing ' +
			        'from "%s"', i + 1, label2)
			});
		} else if (value1['lines'][i] != value2['lines'][i] &&
		    !this.ignoreDiff(value1['lines'][i], value2['lines'][i])) {
			this.push({
			    'label': rowlabel,
			    'messages': [ {
				'source': label1,
			        'message': sprintf('line %d: %s\n',
				    i + 1, value1['lines'][i])
			    }, {
			        'source': label2,
			        'message': sprintf('line %d: %s\n',
				    i + 1, value2['lines'][i])
			    } ]
			});
		}
	}

	setImmediate(callback);
};

DiffStream.prototype.ignoreAddress = function (addr)
{
	var ignore = false;

	switch (addr) {
	case '82741231':
		/*
		 * Subproperty fd268e71 ("_events") is a SlicedString whose
		 * slice is way past the end of its parent string.  The value
		 * should be the empty string, but old versions erroneously
		 * printed some characters here.
		 */
		ignore = true;
		this.vsCounterBump('garbage_SlicedString');
		break;

	case '827b6d4d':
	case '88df1c99':
		/*
		 * 827b6d4d ran into a now-fixed bug in read_heap_dict() that
		 * would emit a bogus property.  827b6d4d refers to 88df1c99, so
		 * its output has the same problem.
		 */
		ignore = true;
		this.vsCounterBump('garbage_read_heap_dict');
		break;

	default:
		break;
	}

	return (ignore);
};

DiffStream.prototype.ignoreDiff = function (value1, value2)
{
	var fixed;

	/*
	 * This function has a lot of regular expressions that confuse jsstyle.
	 */
	/* BEGIN JSSTYLED */

	/*
	 * Many of the difference across the fix for issue #35 result from more
	 * consistent (usually more specific) error messages.
	 */
	if (/<could not read type>/.test(value1) ||
	    /<not a string>/.test(value1) ||
	    /<string \(failed to read length\)/.test(value1) ||
	    /<external string \(failed to read ExternalString data\)/.test(
	    value1) ||
	    /<external string \(failed to read ExternalString ascii data\)/.
	    test(value1) ||
	    /<sliced string \(failed to read offset\)/.test(value1) ||
	    /<sliced string \(failed to read length\)/.test(value1) ||
	    /<external two-byte string>/.test(value1) ||
	    /<external string \(failed to read node external pointer /.
	    test(value1)) {
		if (/<string \(failed to read cons ptrs\)>/.test(value2) ||
		    /<string \(failed to load string\)>/.test(value2) ||
		    /<string \(failed to read offset\)>/.test(value2) ||
		    /<string \(failed to read data\)>/.test(value2)) {
			this.vsCounterBump('more_specific_string_error');
			return (true);
		}
	}

	if (/<external string \(failed to read ExternalString ascii data\)>/.
	    test(value1) &&
	    /"<string \(contents looks invalid\)>"/.test(value2)) {
		this.vsCounterBump('external_string_error');
		return (true);
	}

	/*
	 * The following two checks build on each other.  Do not change the
	 * order without reading the code carefully.
	 */
	fixed = value1.replace(
	    /<sliced string \(failed to read parent type\)>/,
	    '<sliced string (failed to load parent)>');
	if (fixed != value1 && value2 == fixed) {
		this.vsCounterBump('sliced_parent');
		return (true);
	}

	fixed = fixed.replace(
	    /<sliced string \(failed to load parent\)>/,
	    '"<sliced string (failed to load parent)>"');
	if (fixed != value1 && value2 == fixed) {
		this.vsCounterBump('sliced_parent_quoted');
		return (true);
	}

	/*
	 * Similarly, the following two checks build on each other.
	 */
	fixed = value1.replace(
	    /<sliced string \(parent is not a sequential string\)>/,
	    '<sliced string (failed to load parent)>');
	if (fixed != value1 && value2 == fixed) {
		this.vsCounterBump('sliced_parent_seq');
		return (true);
	}

	fixed = fixed.replace(
	    /<sliced string \(failed to load parent\)>/,
	    '"<sliced string (failed to load parent)>"');
	if (fixed != value1 && value2 == fixed) {
		this.vsCounterBump('sliced_parent_seq_quote');
		return (true);
	}

	/*
	 * Some of those differences just relate to quoting.
	 */
	fixed = value2.replace(
	    /"<sliced string \(parent is not a sequential string\)>"/,
	    '<sliced string (parent is not a sequential string)>');
	if (fixed != value2 && value1 == fixed) {
		this.vsCounterBump('proper_quoting');
	    	return (true);
	}

	fixed = value2.replace(
	    /"<external two-byte string>"/,
	    '<external two-byte string>');
	if (fixed != value2 && value1 == fixed) {
		this.vsCounterBump('proper_quoting');
	    	return (true);
	}

	/* END JSSTYLED */

	/*
	 * Check for changes in string truncation.
	 */
	if (this.differOnlyInTruncation(value1, value2)) {
		this.vsCounterBump('truncation');
		return (true);
	}

	return (false);
};

/*
 * Checks whether the two values differ only in the way either the strings
 * themselves or any substrings used therein have been truncated.  When mdb_v8
 * truncates strings, it inserts a marker "[...]".  This has changed across
 * versions:
 *
 *    - Prior to the implementation of issue #35, mdb_v8 would often truncate
 *      strings one character shorter than necessary.  Output for the same
 *      string from old and new versions of mdb_v8 may be off-by-one in the
 *      position of the truncation marker:
 *
 *         actual string: "foo_bartholomew"
 *         old:           "foo_bar[...]"
 *         new:           "foo_bart[...]"
 *
 *    - As a result of the same behavioral difference, if this 1-byte difference
 *      is right at the border of the string's length, this could result in a
 *      string that isn't truncated at all on newer versions:
 *
 *          actual string: "foo_bart"
 *          old:           "foo_bar[...]"
 *          new:           "foo_bart"
 *
 *    - In either of the previous two cases, in some cases the older mdb_v8
 *      would leave out the trailing closing quote ('"') from the output.
 *
 *    - Prior to the implementation of issue #35, mdb_v8 would NOT insert the
 *      "[...]" marker when truncating external ASCII strings.
 *
 * To summarize:
 *
 *    - either string may have any number of truncation markers
 *
 *    - either string may have truncation markers that the other doesn't
 *
 *    - the second string may have an arbitrary extra character before the
 *      truncation marker
 *
 *    - the second string may have an extra '"' character before the truncation
 *      marker
 *
 * Our goal here is to ignore these differences (and _only_ these differences).
 * This implementation is exponential in the number of markers in both strings,
 * but in practice that's extremely small.
 */
DiffStream.prototype.differOnlyInTruncation = function (value1, value2)
{
	var i, p, q, reason;
	var v1before, v1after;
	var v2before, v2after;

	p = value1.indexOf('[...]');
	q = value2.indexOf('[...]');
	if (p == -1) {
		if (q == -1) {
			/*
			 * Neither string has a truncation.  This is a base
			 * case.  The differ logically only if they actually
			 * differ.
			 */
			return (value1 == value2);
		}

		/*
		 * Truncations in the second string are more constrained than
		 * truncations in the first string -- there are no funny edge
		 * cases with the surrounding characters, and the part of
		 * "value1" that corresponds to the truncation marker must be
		 * the same length as the marker.  (If it were shorter, it
		 * wouldn't have been truncated on newer versions.  If it were
		 * longer, it wouldn't have fit in the same buffer as the
		 * marker.)
		 */
		v2before = value2.substr(0, q);
		v1before = value1.substr(0, q);
		if (v1before != v2before) {
			return (false);
		}

		/*
		 * We always need to make a recursive call for the tails of the
		 * strings in case there are more truncation markers.
		 */
		v2after = value2.substr(q + '[...]'.length);
		v1after = value1.substr(q + '[...]'.length);
		return (this.differOnlyInTruncation(v1after, v2after));
	}

	v1before = value1.substr(0, p);
	v1after = value1.substr(p + '[...]'.length);

	if (q != -1 && (q == p || q == p + 1 || q == p + 2)) {
		/*
		 * Both strings have a truncation marker, and they're within 2
		 * characters of the same position.  They must represent the
		 * same truncation.
		 *
		 * We basically want to compare what's before and after the
		 * marker, but there are edge cases on either side, so it's
		 * easier to break these checks out separately.
		 *
		 * First, compare the substrings before the "[...]" marker.
		 * Remember, the second substring may have an extra character or
		 * two, in which case we'll ignore it.
		 */
		v2before = value2.substr(0, p);

		if (v1before != v2before) {
			/*
			 * The strings differ in more than just truncation
			 * because the parts before the truncation mark don't
			 * match up (even allowing for the possible extra
			 * characters in the second string).
			 */
			return (false);
		}

		/*
		 * Now, compare the substrings after the "[...]" marker.
		 * Remember, the second substring may have an extra '"'
		 * character.
		 */
		v2after = value2.substr(q + '[...]'.length);
		if (v2after.charAt(0) == '"' && v1after.charAt(0) != '"') {
			v2after = value2.substr(q + '[...]"'.length);
			reason = 'trunc_accurate_truncation_plus_quote';
		} else {
			reason = 'trunc_accurate_truncation';
		}

		if (!this.differOnlyInTruncation(v1after, v2after)) {
			return (false);
		}

		this.vsCounterBump(reason);
		return (true);
	}

	/*
	 * The second string either does not have a truncation marker or it
	 * appears to be much later in the string.  In either case, we're going
	 * to ignore it until the recursive call.
	 *
	 * As above, we'll first check everything up to the truncation mark in
	 * the first string.
	 */
	v2before = value2.substr(0, p);
	if (v1before != v2before) {
		/*
		 * The strings don't match up even before we get to the
		 * truncation marker.
		 */
		return (false);
	}

	/*
	 * Now check that the tails of the strings match.  There may be one or
	 * two extra characters, and sadly, we have to check both.
	 */
	for (i = 1; i <= 2; i++) {
		v2after = value2.substr(p + '[...]'.length + i);
		if (v2after.charAt(0) == '"' && v1after.charAt(0) != '"') {
			v2after = v2after.substr(1);
			reason = 'trunc_unneccessary_truncation_plus_quote';
		} else {
			reason = 'trunc_unneccessary_truncation';
		}

		if (this.differOnlyInTruncation(v1after, v2after)) {
			this.vsCounterBump(reason);
			return (true);
		}
	}

	return (false);
};

function DiffStreamSerializer()
{
	mod_stream.Transform.call(this, { 'objectMode': true });
}

mod_util.inherits(DiffStreamSerializer, mod_stream.Transform);

DiffStreamSerializer.prototype._transform = function (obj, _, callback)
{
	var self = this;

	if (obj.hasOwnProperty('message')) {
		self.push(sprintf('%s: %s\n', obj['label'], obj['message']));
	} else {
		obj['messages'].forEach(function (m) {
			self.push(sprintf('%s: %s: %s',
			    obj['label'], m['source'], m['message']));
		});
	}

	setImmediate(callback);
};


main();
